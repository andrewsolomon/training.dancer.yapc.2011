Elementary Web Application
===========================

Concepts:
- Route handler - the mapping of a path to a subroutine
- Route types:
    1. /link/:like/:this where all the data is in the url but not a GET
    2. GET query 
    3. POST query
- Template


We assume you've done a static website. A simple HTML page.
The only active part of a static website is a link to
take you from one static page to another.
Eg. <a href="http://www.google.com">Google</a>

More interesting is our website where clicking on a button
will do some data mining and generate a new page on the fly.
That's a 'Web Application' and this class will take you through
putting together a web application.


Exercise 1
===========
Create the script part1/ex1/step1.pl

====
#!/usr/bin/perl

use Dancer;

set logger  => 'console';
set log     => 'debug';
set show_errors => 1;

get '/' => sub {
    return "Hello World!";
};

Dancer->dance;

====
running it at the command line you should get something like:
===
$ ./hw
>> Dancer server 11757 listening on http://0.0.0.0:3000
===

See what happens when you visit the url with your browser.
If this doesn't work, replace '0.0.0.0' with 'localhost' or the IP address
of the machine you're working on.


Things to note about the code:
* 'use Dancer' brings along 'use strict' and 'use warnings' so 
we don't need to type them.
* The three settings
  set logger    => 'console';
  set log       => 'debug';
  set show_errors => 1;
are telling it to keep you informed of what the problem is when
you're coding to make sure you get as much information as possible.
You'll want to log errors to a file once it's a public website.
* get '/' => sub {} 
says, on an HTTP GET request, call the subroutine on the right 
of the arrow to generate the content of the page to be displayed.
* Dancer->dance ;
This is an example of a method call on an object. To use Moose we don't
need to understand how to develop Perl objects - we just need to get a
feel for how to use them.


In part1/ex1/step1.pl these commands would have looked a bit
suspicious to the Perl newbie:

set logger    => 'console';
get '/' => sub {
    return "Hello World!";
};

This is just a bit of Perl cosmetics to change the focus of 
the reader from the subroutine being called, to its arguments.

The first of these could just as well have been written

set('logger', 'console');

Rewrite the whole script in this way and save it as 

part1/ex1/step1-back.pl


Hint: to understand the get's second argument set

my $hwsub = sub {
    return "Hello World!";
};

before calling 'get' on it.

========================


Copy part1/ex1/step1.pl to part1/ex1/step2-forward.pl

and change the output to be a bit prettier using HTML tags.

<h1>Hello World!</h1>
================================================================

Exercise 2: 

Copy part1/ex1/step2-forward.pl to Copy part1/ex2/step1.pl

and create another web page for the url
    http://localhost:3000/hello
which returns '<h1>Turn it all around people!</h1>'

Hint: Instead of get's first argument as '/' it should be '/hello'

=================================================================

Exercise 3: Non-static pages
============================

We've shown how to write static pages, but that's no better
than plain HTML. 

Copy part1/ex1/step2-forward.pl to part1/ex3/step1.pl
and add a new route handler 'date_time' which shows not just 'Hello World', but also
the time.

http://localhost:3000/date_time

'Hello world, the time is now 2002-12-06 14:02:29'

Hints: 
* Calculate the time using the DateTime module, it's 'now' creation method, and  its 'ymd' and 'hms' methods.
* $ perldoc DateTime
* my $time = DateTime->now(time_zone => 'Europe/Riga');
my $s_date = $time->ymd; my $s_time = $time->hms;



Exercise 4: Template Toolkit
=============================

Now from the previous exercise you are generating HTML from 
within a script. For a small and simple HTML file that's ok, but
if it gets any bigger it will be very difficult to read the 
script picking out the html from the perl or vice versa.

This is what a Template is for - you can separate out the 
HTML into a different file with tags [% date %] and [% time %]
which will be filled in by the variables in the perl script.

Now, copy part1/ex3/step1.pl to part1/ex4/step1.pl

and change the  

    get '/time' 

route handler. Instead of returning an HTML string, return

    template 'date_time' => { time => $now->hms, date => $now->ymd };
or 
    template('date_time', { time => $now->hms, date => $now->ymd });

if it makes you feel safer :)


At the top of the file, add these configuration parameters telling
Dancer you'll be using a template file.

 set engines => {
     template_toolkit => 
     {
         start_tag => '[%',
         stop_tag  => '%]'
     }
 };
 set template  => 'template_toolkit';


Now, running the script and pointing your browser at
http://10.5.16.131:3000/time 
will give you a runtime errors saying that it's looking
for the file
code/part1/ex4/views/date_time.tt

To fix this, create the file with any HTML content you like, 
and making use of the strings [% date %] and [% time %]
which will be filled in by Dancer::Template

Run it and make sure it works.
The things to note about this:
- 'template 'date_time'' means 'look for views/date_time.tt in the views directory
- the hash ref  { time => $now->hms, date => $now->ymd } says
'Whenever you see [% time %] replace it with $now->hms and
whenever you see [% date %] replace it with  $now->ymd 


Exercise 4 Step 2
------------------
Copy part1/ex4/step1.pl to part1/ex4/step2_backwards.pl

and swap the order of the 'set template' and 'set engines'

What happens?

[It's a Dancer bug - no-one's perfect!]

========================

Exercise 5. Route Type 1: parameterised base url

Copy ./code/part1/ex2/step1.pl to ./code/part1/ex5/step1.pl

Modify the /hello route handler to take another parameter.

That is, instead of writing 
get '/hello' => sub {}
we write 
get '/hello/:adjective' => sub {}

Then within the associated subroutine, the variable
params->{adjective} will be the string in the url after 
/hello-adj-par/ 

NOTE: params is a method returning a hashref of all the parameters

Therefore, we can change 
  return "<h1>Turn it all around people!</h1>";
to     
  return "<h1>Turn it all around ".params->{adjective}." people!</h1>";


Then navigate to the page: 
  http://10.1.1.5:3000/hello/funny

or 
  http://10.1.1.5:3000/hello/interesting

Implement this and see that it works.

NOTES:
* This technique is great for auto-generated urls which might populate
a site-map for search engines to explore your website.
* What's more - it's much prettier as a url than the two other approaches below.

==============================
FIXME UPTO HERE
==============================


Exercise 6. Dynamic Content 2: GET query 
=========================================

Exercise 5 shows how we can use paramaterised urls for generating content,
but this is not the way for implementing pages which take their parameters
from human input. You don't want them to have to type their name into the
url.  It would be easier for them to type it into a field in a web page.

The two approaches for implementing this are the GET and POST type forms.  
The first thing we need to implement (A) is a page which takes the user's 
adjective input.  The second (B) is a page to display the output.

A) Create a new file views/hello-adj-index.tt containing

-----
<h1>GET form for accessing the hello-adj-get method</h1>
<form action="hello-adj-get" method="get">
  Adjective: <input type="text" name="adjective" /><br />
  <input type="submit" value="Submit" />
</form>
-----

In hw, add a '/hello-adj-index' method

-----------

get '/hello-adj-index' => sub {
  template 'hello-adj-index';
};
-------

B) In hw add a method for /hello-adj

----------

get '/hello-adj' => sub {
  my $params = params();
    return
  "<h1>Hello ".params->{adjective}." Things!</h1>".
};
--------

Run it and see that if you visit the website at 

http://localhost:3000/hello-adj-index
and enter a name like 'dynamic' and click submit, it will 
display the page 
http://10.1.1.5:3000/hello-adj?adjective=dynamic
and say 'Hello dynamic Things!'

Exercise 7. Dynamic content 3: POST query 

You've just done two experiments with dynamically generating content of the
web page based on information the user provided. In both cases, this
information wound up in the url.

This is sometimes not optimal, for example when the string provided by
the user is their password (and therefore visible in the url), 
or longer than the maximum url length (2083 characters for IE)

The solution to this is to use a POST request, rather than a 
GET request. In a POST request, the query parameters are 
in the HTTP message's header, rather than the url.

With a POST we need to do two things. First of all, provide a POST
form in the template views/hello-adj-index.tt - after the get form.
-----
<h1>POST form for accessing the hello-adj-post method</h1>
<form action="hello-adj" method="post">
  Adjective: <input type="text" name="adjective" /><br />
  <input type="submit" value="Submit" />
</form>
-----


And then in the hw controller add the "hello-adj" method this will call.

----------

post '/hello-adj' => sub {
  my $params = params();
    return
  "<h1>Hello ".params->{adjective}." Things!</h1>".
};
--------

Run it and see that if you visit the website at 

http://localhost:3000/hello-adj-index
enter a name like 'dynamic' *in the post form* and click submit, it will 
display the page 
http://localhost:3000/hello-adj
and say 'Hello dynamic Things!'



Exercise 8: Dynamic Content + Template Toolkit
==============================================


Implement a new GET query so that if the user enters a comma-separated
list of adjectives it prints out a line for each one.


A. First there's the new form to be appended to views/hello-adj-index.tt
-----
<h1>GET form for accessing hello-multiple-adj-get method</h1>
<form action="hello-multiple-adj" method="get">
  Adjective: <input type="text" name="adjectives" /><br />
  <input type="submit" value="Submit" />
</form>
-----


In hw, add a '/hello-multiple-adj' method

----------

get '/hello_multiple_adj' => sub {
  my $params = params();
  ## TODO: Split the params->{adjectives} into a list of comma separated words
  ## and we pass a refence to this list into TT
  template 'hello-multiple-adj' => { adjective_list => \@adj_list };
};
--------

B. Now we must implement a new template view  and
this is where the Template Toolkit shows its power!  


Write this code in views/hello-multiple-adj.tt

-----------------------------------
[% FOREACH adj in adjective_list %]
<p>Hello [% adj %] thing!</p>
[% END %]
-----------------------------------


Check to see that it runs as expected.
[markme]


Exercise 9
===========

In Exercise 8 we saw how to use the FOREACH loop to show the
contents of an array where each element was a string.

In this example, we show the contents of a hashref.
This is a very simple example but it illuminates 
how hashrefs are represented in TT.

Write a webpage http://localhost:3000/show-parameters 
which displays everything it receives as a parameter.

For example:

http://localhosit:3000/show-parameters?x=1&y=2&z=t

shows a webpage of 
========================
Parameters

Key Value
x 1
y 2
z t
========================


See perldoc Template::Manual::Directives

A) Write a route handler in hw:
---
get '/show-parameters' => sub {
  my $rh_params = params;
  template 'parameters' => { parameter_hashref =>  $rh_params };
};
---
Noting that writing just 
  template 'parameters' => { parameter_hashref =>  params };
won't work. Called in this way 'params' returns a hash, rather than a hashref.
To understand why is beyond the scope of this course, but
to findout more, read the Dancer::Request code implementing 'params' in
5.10.1/Dancer/Request.pm
and read
$ perldoc -f wantarray


B) Write the parameters template (parameters.tt)
with a FOREACH loop which iterates over each key-value pair 
of the 'parameter_hashref' variable

---

<h1>Parameters</h1>

<table>
<tr><td><b>Key</b></td><td><b>Value</b></td></tr>
[% FOREACH p IN parameter_hashref %]

---->INSERT YOUR CODE HERE

[% END %]

</table>

---

To figure out how, read 

'iterated values which are hash references' in 

perldoc Template::Manual::Directives

[marking: just call the url with various parameters]




